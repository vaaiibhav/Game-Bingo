//TODO 保存？

const BrowserWindow = require('electron').BrowserWindow;
const os = require('os');

let ipc = require('electron').ipcMain;
let sender = require('./libs/sender');
const storage = require('electron-json-storage');
storage.setDataPath(os.tmpdir());
function randomString(len) {
    len = len || 32;
    var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678';
    var maxPos = $chars.length;
    var pwd = '';
    for (i = 0; i < len; i++) {
        pwd += $chars.charAt(Math.floor(Math.random() * maxPos));
    }
    return pwd;
}
function addHistory(arg) {
    return new Promise((resolve, reject)=> {
        storage.get('printHistory', (error, data)=> {
            if (error) {
                reject();
            } else {
                if (!data.logs) {
                    data = {};
                    data.logs = [];
                }
                resolve(data);
            }
        });
    }).then((data)=> {
        return new Promise((resolve, reject)=> {
            arg.id = `${randomString(20)}${new Date().getTime()}`;
            data.logs.push(arg);
            if (data.logs.length > 100) {
                data.logs.shift();
            }
            storage.set('printHistory', data, (error)=> {
                if (error) {
                    reject();
                } else {
                    resolve();
                }
            })
        });
    });
}
function getHistoryList() {
    return new Promise((resolve, reject)=> {
        storage.get('printHistory', (error, data)=> {
            if (error) {
                reject();
            } else {
                resolve(data);
            }
        })
    });
}
function getHistory(id) {
    return getHistoryList().then((data)=> {
        console.log(data);
        return new Promise((resolve, reject)=> {
            for (let i = 0; i < data.logs.length; i++) {
                if (data.logs[i].id == id) {
                    resolve([data.logs[i], i]);
                    return;
                }
            }
            reject('cannot find id');
        });
    })
}
function setHistory(id, arg) {
    return getHistory(id).then(([item, i])=> {
        return new Promise((resolve, reject)=> {
            getHistoryList().then((data)=> {
                resolve([data, i]);
            })
        })
    }).then(([data,i])=> {
        return new Promise((resolve, reject)=> {
            data.logs[i] = arg;
            storage.set('printHistory', data, (error)=> {
                if (error) {
                    reject();
                } else {
                    resolve(arg);
                }
            })
        });
    });
}
ipc.on('print-clear', (event, id)=> {
    storage.set('printHistory', {}, (error, data)=> {
        event.returnValue = true;
    });
});
ipc.on('print-get', (event, id)=> {
    getHistory(id).then(([result,id])=> {
        event.returnValue = result;
    });
});
ipc.on('print-set', (event, arg)=> {
    setHistory(arg.id, arg.data).then((result)=> {
        console.log(result);
        event.returnValue = result;
    });
});
ipc.on('print-get-list', (event, arg)=> {
    getHistoryList().then((result)=> {
        event.returnValue = result;
    });
});
// return promise
function print58m(arg) {
return new Promise((resolve,reject)=>{
    let resultSent = false;
    let timeoutPerLine = arg.timeoutPerLine ? arg.timeoutPerLine : 200;
    if (!arg.preview) {
        setTimeout(function () {
            if (!resultSent) {
                reject();
                resultSent = true;
            }
        }, timeoutPerLine * arg.data.length + 1000);
        addHistory(arg);
    }
    let mainWindow = new BrowserWindow({width: 210, height: 1200, show: arg.preview});
    mainWindow.on('closed', function () {
        mainWindow = null;
    });
    mainWindow.loadURL('file://' + __dirname + '/58mPage.html');
    mainWindow.webContents.on('did-finish-load', () => {
        let data = arg.data;
        new Promise((resolve, reject)=> {
            printLine(0);
            function printLine(line) {
                if (line >= data.length) {
                    resolve();
                    return;
                }
                let obj = data[line];
                switch (obj.type) {
                    case 'text':
                        sender('print-text', mainWindow.webContents, obj).then((result)=> {
                            printLine(line + 1);
                        });
                        break;
                    case 'barcode':
                        sender('print-barcode', mainWindow.webContents, obj).then((result)=> {
                            printLine(line + 1);
                        });
                        break;
                    case 'qrcode':
                        sender('print-qrcode', mainWindow.webContents, obj).then((result)=> {
                            printLine(line + 1);
                        });
                        break;
                    case 'bodyInit':
                        sender('print-body-init', mainWindow.webContents, obj).then((result)=> {
                            printLine(line + 1);
                        });
                        break;
                }
            }
        }).then(()=> {
            if (!arg.preview) {
                mainWindow.webContents.print({
                    silent: true,
                    printBackground: true,
                    deviceName: arg.deviceName
                }, function (arg) {
                    if (!resultSent) {
                        resolve(arg);
                        resultSent = true;
                    }
                    mainWindow.close();
                });
            } else {
                resolve(arg);
            }
        });
    })
});
}
ipc.on('print-58m', (event, arg)=> {
    print58m(arg).then((arg)=>{
        event.sender.send('print-58m-reply', arg);
    }).catch(()=>{
        event.sender.send('print-58m-reply', false);
    });
});

module.exports.print58m=(arg)=>{
    return print58m(arg);
};